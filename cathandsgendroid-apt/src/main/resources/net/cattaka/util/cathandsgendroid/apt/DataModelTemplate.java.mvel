package @{packageName};

import net.cattaka.util.cathandsgendroid.accessor.IAccessor;
import net.cattaka.util.cathandsgendroid.accessor.Accessor;
@if{annotation.genDbFunc() || annotation.genContentResolverFunc()}
import android.content.ContentValues;
import android.database.Cursor;
@end{}
@if{annotation.genDbFunc()}
import android.database.sqlite.SQLiteDatabase;
@end{}
@if{annotation.genContentResolverFunc()}
import android.content.ContentResolver;
import android.net.Uri;
@end{}
@foreach{importClass:importClasses}
import @{importClass};@end{}


/**
 * This class is auto-generated by APT; please do not edit by hand.
 */
public class @{genClassName} {
@foreach{fieldEntry : fieldEntries}
    public static final IAccessor<@{fieldEntry.javaDataType}> ACCESSOR_@{fieldEntry.compositeName};@end{}
    
    static {
@foreach{fieldEntry : fieldEntries}
        ACCESSOR_@{fieldEntry.compositeName} = @{fieldEntry.accessor};@end{}
    }

@if{annotation.genDbFunc() || annotation.genContentResolverFunc()}
    public static final String SQL_CREATE_TABLE = "CREATE TABLE ${tableName}(@code{counter = 0}@foreach{fieldEntry : fieldEntries}@{(counter++>0)?",":""}@{fieldEntry.columnName} @{fieldEntry.dbDataType}@{fieldEntry.primaryKey ? " PRIMARY KEY"+(annotation.autoincrement()?" AUTOINCREMENT":""):""}@end{})";
@if{findEntriesPerVersions.size()>0}@code{counter=0;lastVersion=0;}@foreach{item:findEntriesPerVersions}@if{counter++>0}
    public static final String[] SQL_ALTER_TABLE_@{lastVersion}_TO_@{item.version} = new String[] {
@foreach{fieldEntry:item.fieldEntries}
        "ALTER TABLE @{tableName} ADD COLUMN @{fieldEntry.columnName} @{fieldEntry.dbDataType}",@end{}
    };
@end{}@code{lastVersion=item.version}@end{}@end{}
    public static final String TABLE_NAME = "@{tableName}";
    public static final String COLUMNS = "@code{counter = 0}@foreach{fieldEntry : fieldEntries}@{(counter++>0)?",":""}@{fieldEntry.columnName}@end{}";
    public static final String[] COLUMNS_ARRAY = new String[] {@code{counter = 0}@foreach{fieldEntry : fieldEntries}@{(counter++>0)?",":""}"@{fieldEntry.columnName}"@end{}};
@code{counter = 0}@foreach{fieldEntry : fieldEntries}
    public static final int COL_INDEX_@{fieldEntry.compositeName} = @{counter++};@end{}
@code{counter = 0}@foreach{fieldEntry : fieldEntries}
    public static final String COL_NAME_@{fieldEntry.compositeName} = "@{fieldEntry.columnName}";@end{}

    public static void readCursorByIndex(Cursor cursor, @{className} dest) {
@code{counter = 0}@foreach{fieldEntry : fieldEntries}
@if{fieldEntry.primitiveType}        { @{fieldEntry.javaDataType} v = ACCESSOR_@{fieldEntry.compositeName}.readFromCursor(cursor,${counter++}); if (v != null) dest.@{fieldEntry.setter}(v); }@comment{
}@else{}        dest.@{fieldEntry.setter}(ACCESSOR_@{fieldEntry.compositeName}.readFromCursor(cursor,${counter++}));@comment{
}@end{}@end{}
    }
    
    public static @{className} readCursorByIndex(Cursor cursor) {
        @{className} result = new @{className}();
        readCursorByIndex(cursor, result);
        return result;
    }
    public static void readCursorByName(Cursor cursor, @{className} dest) {
        int idx;
@foreach{fieldEntry : fieldEntries}
        idx = cursor.getColumnIndex("${fieldEntry.columnName}");
@if{fieldEntry.primitiveType}        { @{fieldEntry.javaDataType} v = ACCESSOR_@{fieldEntry.compositeName}.readFromCursor(cursor,idx); if (v != null) dest.@{fieldEntry.setter}(v); }@comment{
}@else{}        dest.@{fieldEntry.setter}(ACCESSOR_@{fieldEntry.compositeName}.readFromCursor(cursor,idx));@comment{
}@end{}@end{}
    }
    public static @{className} readCursorByName(Cursor cursor) {
        @{className} result = new @{className}();
        readCursorByName(cursor, result);
        return result;
    }
    public static void putToContentValues(ContentValues dest, @{className} model, boolean withPrimaryKey) {
        if (withPrimaryKey) {
            ACCESSOR_@{?primaryKey.compositeName}.putToContentValues(dest, "@{?primaryKey.columnName}", model.@{?primaryKey.getter}());
        }
@foreach{fieldEntry : fieldEntries}@if{!fieldEntry.primaryKey}
        ACCESSOR_@{fieldEntry.compositeName}.putToContentValues(dest, "@{fieldEntry.columnName}", model.@{fieldEntry.getter}());@end{}@end{}
    }


@comment{ ==== DbFunc ==== }
@if{annotation.genDbFunc()}
    public static long insert(SQLiteDatabase db, @{className} model) {
        ContentValues values = new ContentValues();
        putToContentValues(values, model, ${annotation.autoincrement()?"false":"true"});
        long key = db.insert(TABLE_NAME, null, values);
        return key;
    }
    public static int update(SQLiteDatabase db, @{className} model) {
        ContentValues values = new ContentValues();
        String whereClause = "${?primaryKey.columnName}=?";
        String[] whereArgs = new String[]{ACCESSOR_@{?primaryKey.compositeName}.stringValue(model.${?primaryKey.getter}())};
        putToContentValues(values, model, false);
        return db.update(TABLE_NAME, values, whereClause, whereArgs);
    }
    public static int delete(SQLiteDatabase db, ${?primaryKey.javaDataType} key) {
        String whereClause = "${?primaryKey.columnName}=?";
        String[] whereArgs = new String[]{ACCESSOR_@{?primaryKey.compositeName}.stringValue(key)};
        return db.delete(TABLE_NAME, whereClause, whereArgs);
    }

@foreach{findEntry : findEntries}
@code{
    counter=0;
    methodName = "";
    if (findEntry.columns.size() > 0) {
        methodName += "By";
	    foreach(column:findEntry.columns) {
	        if(counter++>0){methodName+="And";}
	        methodName+=column.columnNameCapped;
	    }
	    }
    if (!findEntry.unique && findEntry.orderBy.size() > 0) {
        methodName+="OrderBy";
        counter = 0;
        foreach(orderBy:findEntry.orderBy) {
            if (counter++>0) {methodName+="And";}
            methodName+=orderBy.fieldEntry.columnNameCapped + (orderBy.desc?"Desc":"Asc");
        }
    }
    findMethodName = "find" + methodName;
    cursorMethodName = "findCursor" + methodName;
}
@if{findEntry.unique}
    public static @{className} @{findMethodName}(SQLiteDatabase db@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        Cursor cursor = @{cursorMethodName}(db@foreach{column:findEntry.columns}, @{column.origName}@end{});
        @{className} model = (cursor.moveToNext()) ? readCursorByIndex(cursor) : null;
        cursor.close();
        return model;
    }
    public static Cursor ${cursorMethodName}(SQLiteDatabase db@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        String selection = "@code{counter=0}@foreach{column:findEntry.columns}@{counter++>0?" AND ":""}@{column.columnName}=?@end{}";
        String[] selectionArgs = new String[]{
@foreach{column:findEntry.columns}
            ACCESSOR_@{column.compositeName}.stringValue(${column.origName}),@end{}
        };
        return db.query(TABLE_NAME, COLUMNS_ARRAY, selection, selectionArgs, null, null, null);
    }
@else{}
    public static java.util.List<@{className}> @{findMethodName}(SQLiteDatabase db, int limit@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        Cursor cursor = @{cursorMethodName}(db, limit@foreach{column:findEntry.columns}, @{column.origName}@end{});
        java.util.List<@{className}> result = new java.util.ArrayList<@{className}>();
        while (cursor.moveToNext()) {
            result.add(readCursorByIndex(cursor));
        }
        cursor.close();
        return result;
    }
    public static Cursor ${cursorMethodName}(SQLiteDatabase db, int limit@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        String selection = "@code{counter=0}@foreach{column:findEntry.columns}@{counter++>0?" AND ":""}@{column.columnName}=?@end{}";
        String[] selectionArgs = new String[]{
@foreach{column:findEntry.columns}
            ACCESSOR_@{column.compositeName}.stringValue(${column.origName}),@end{}
        };
        String limitStr = (limit > 0) ? String.valueOf(limit) : null;
@if{findEntry.orderBy.size()>0}
        String orderBy = "@code{counter=0}@foreach{orderBy:findEntry.orderBy}@{counter++>0?",":""}@{orderBy.fieldEntry.columnName} @{orderBy.desc?"desc":"asc"}@end{}";
        return db.query(TABLE_NAME, COLUMNS_ARRAY, selection, selectionArgs, null, null, orderBy, limitStr);
@else{}
        return db.query(TABLE_NAME, COLUMNS_ARRAY, selection, selectionArgs, null, null, null, limitStr);
@end{}@comment{findEntry.orderBy.size()>0}
    }
@end{}@comment{@if{findEntry.unique}}
@end{}@comment{@foreach{findEntry : findEntries}}
@end{}@comment{@if{annotation.genDbFunc()}}


@comment{ ==== genContenrResolver ==== }
@if{annotation.genContentResolverFunc()}
    public static Uri insert(ContentResolver resolver, Uri uri, @{className} model) {
        ContentValues values = new ContentValues();
        putToContentValues(values, model, ${annotation.autoincrement()?"false":"true"});
        return resolver.insert(uri, values);
    }
    public static int update(ContentResolver resolver, Uri uri, @{className} model) {
        ContentValues values = new ContentValues();
        String whereClause = "${?primaryKey.columnName}=?";
        String[] whereArgs = new String[]{ACCESSOR_@{?primaryKey.compositeName}.stringValue(model.${?primaryKey.getter}())};
        putToContentValues(values, model, false);
        return resolver.update(uri, values, whereClause, whereArgs);
    }
    public static int delete(ContentResolver resolver, Uri uri, ${?primaryKey.javaDataType} key) {
        String whereClause = "${?primaryKey.columnName}=?";
        String[] whereArgs = new String[]{ACCESSOR_@{?primaryKey.compositeName}.stringValue(key)};
        return resolver.delete(uri, whereClause, whereArgs);
    }

@foreach{findEntry : findEntries}
@code{
    counter=0;
    methodName = "";
    if (findEntry.columns.size() > 0) {
        methodName += "By";
        foreach(column:findEntry.columns) {
            if(counter++>0){methodName+="And";}
            methodName+=column.columnNameCapped;
        }
        }
    if (!findEntry.unique && findEntry.orderBy.size() > 0) {
        methodName+="OrderBy";
        counter = 0;
        foreach(orderBy:findEntry.orderBy) {
            if (counter++>0) {methodName+="And";}
            methodName+=orderBy.fieldEntry.columnNameCapped + (orderBy.desc?"Desc":"Asc");
        }
    }
    findMethodName = "find" + methodName;
    cursorMethodName = "findCursor" + methodName;
}
@if{findEntry.unique}
    public static @{className} @{findMethodName}(ContentResolver resolver, Uri uri@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        Cursor cursor = @{cursorMethodName}(resolver,uri@foreach{column:findEntry.columns}, @{column.origName}@end{});
        @{className} model = (cursor.moveToNext()) ? readCursorByIndex(cursor) : null;
        cursor.close();
        return model;
    }
    public static Cursor ${cursorMethodName}(ContentResolver resolver, Uri uri@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        String selection = "@code{counter=0}@foreach{column:findEntry.columns}@{counter++>0?" AND ":""}@{column.columnName}=?@end{}";
        String[] selectionArgs = new String[]{
@foreach{column:findEntry.columns}
            ACCESSOR_@{column.compositeName}.stringValue(${column.origName}),@end{}
        };
        return resolver.query(uri, COLUMNS_ARRAY, selection, selectionArgs, null);
    }
@else{}
    public static java.util.List<@{className}> @{findMethodName}(ContentResolver resolver, Uri uri@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        Cursor cursor = @{cursorMethodName}(resolver,uri@foreach{column:findEntry.columns}, @{column.origName}@end{});
        java.util.List<@{className}> result = new java.util.ArrayList<@{className}>();
        while (cursor.moveToNext()) {
            result.add(readCursorByIndex(cursor));
        }
        cursor.close();
        return result;
    }
    public static Cursor ${cursorMethodName}(ContentResolver resolver, Uri uri@foreach{column:findEntry.columns}, @{column.javaDataType} @{column.origName}@end{}) {
        String selection = "@code{counter=0}@foreach{column:findEntry.columns}@{counter++>0?" AND ":""}@{column.columnName}=?@end{}";
        String[] selectionArgs = new String[]{
@foreach{column:findEntry.columns}
            ACCESSOR_@{column.compositeName}.stringValue(${column.origName}),@end{}
        };
@if{findEntry.orderBy.size()>0}
        String orderBy = "@code{counter=0}@foreach{orderBy:findEntry.orderBy}@{counter++>0?",":""}@{orderBy.fieldEntry.columnName} @{orderBy.desc?"desc":"asc"}@end{}";
        return resolver.query(uri, COLUMNS_ARRAY, selection, selectionArgs, orderBy);
@else{}
        return resolver.query(uri, COLUMNS_ARRAY, selection, selectionArgs, null);
@end{}@comment{findEntry.orderBy.size()>0}
    }
@end{}@comment{@if{findEntry.unique}}
@end{}@comment{@foreach{findEntry : findEntries}}
@end{}@comment{@if{annotation.genContentResolverFunc()}}

@end{}@comment{@if{annotation.genDbFunc() || annotation.genContentResolverFunc()}}



@comment{ ==== ParcelFunc ==== }
@if{annotation.genParcelFunc()}
    public static final android.os.Parcelable.Creator<@{className}> CREATOR = new android.os.Parcelable.Creator<@{className}>() {
        @Override
        public @{className} createFromParcel(android.os.Parcel in) {
            @{className} dest = new @{className}();
            readFromParcel(dest, in);
            return dest;
        }
        @Override
        public @{className}[] newArray(int size) {
            return new @{className}[size];
        }
    };
    public static void readFromParcel(@{className} dest, android.os.Parcel in) {
@foreach{fieldEntry : fieldEntries}@if{!fieldEntry.primaryKey}
        dest.@{fieldEntry.setter}(ACCESSOR_@{fieldEntry.compositeName}.readFromParcel(in));@end{}@end{}
    }
    public static void writeToParcel(@{className} src, android.os.Parcel out, int flags) {
@foreach{fieldEntry : fieldEntries}@if{!fieldEntry.primaryKey}
        ACCESSOR_@{fieldEntry.compositeName}.writeToParcel(out, src.@{fieldEntry.getter}());@end{}@end{}
    }
@end{}
}
